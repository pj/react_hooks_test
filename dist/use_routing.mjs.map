{"version":3,"file":"use_routing.mjs","sources":["../src/useRouting.tsx"],"sourcesContent":["import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {URL} from \"url\";\nconst VALID_IDENTIFIER = '[a-zA-Z_][a-zA-Z_0-9]*';\nconst stringType = '(.*)';\n\nexport function parseRoute(route: string) {\n  const url = new URL(route, 'http://hello');\n\n  const segments = [];\n  const params = new Map();\n\n  const typeType = '(string|number|boolean)';\n  const typePath = new RegExp(`^(${VALID_IDENTIFIER})=${typeType}$`);\n  const intType = '(\\\\d+)';\n  const floatType = '(\\\\d+\\.\\\\d+)';\n  const boolType = '(true|false)';\n  const stringType = '(.*)';\n  const partPath = new RegExp(`^(${VALID_IDENTIFIER})$`);\n\n  const pathParts = url.pathname.split('/');\n  for (let part of pathParts) {\n    if (part === '') {\n      continue;\n    }\n\n    let match = part.match(typePath);\n\n    if (match) {\n      segments.push({name: match[1], type: match[2], _default: null});\n      continue;\n    }\n\n    match = part.match(partPath);\n\n    if (match) {\n      segments.push({name: match[1], type: 'path', _default: null});\n      continue;\n    }\n\n    throw new Error(`Invalid path part ${part} in route ${route}`);\n  }\n\n  // @ts-ignore\n  for (let entry of url.searchParams) {\n    let key = entry[0];\n    let value = entry[1];\n\n    let match = value.match(typeType);\n    if (match) {\n      params.set(key, {type: value, _default: null});\n      continue;\n    }\n\n    match = value.match(floatType);\n    if (match) {\n      params.set(key, {type: 'number', _default: parseFloat(value)});\n      continue;\n    }\n\n    match = value.match(intType);\n    if (match) {\n      params.set(key, {type: 'number', _default: parseInt(value)});\n      continue;\n    }\n\n    match = value.match(boolType);\n    if (match) {\n      params.set(key, {type: 'boolean', _default: value === 'true'});\n      continue;\n    }\n\n    match = value.match(stringType);\n    if (match) {\n      params.set(key, {type: 'string', _default: value});\n      continue;\n    }\n\n    throw new Error(`Invalid query parameter name: ${key} value: ${value} in route: ${route}`)\n  }\n\n  return {path: segments, params: params};\n}\n\ntype RoutePart = {\n  _type: 'path' | 'string' | 'number' | 'boolean';\n  name: string;\n};\n\ntype Param = {\n  _type: 'path' | 'string' | 'number' | 'boolean';\n  _default: string | number | boolean | null;\n};\n\ntype Route = {\n  path: RoutePart[],\n  params: Map<string, Param>\n};\n\ntype RouteState = {\n  [key: string]: string | number | boolean;\n}\n\nexport function matchRouteAndGenerateState(\n  hash: string,\n  routes: Map<string, Route>\n) {\n  hash = hash.replace('#', '');\n  const url = new URL(hash, 'https://hello');\n  let pathSplit = url.pathname.split('/');\n  pathSplit = pathSplit.filter((part) => !part.match(/^\\s*$/));\n  let newState = ({} as RouteState);\n\n  goto_routes:\n  for (let nameRoute of routes) {\n    let name = nameRoute[0];\n    let route = nameRoute[1];\n    let routePath = route.path;\n    let routeParams = route.params;\n    newState = {};\n    if (routePath.length === pathSplit.length) {\n      for (let n = 0; n < routePath.length; n++) {\n        const routePart = routePath[n];\n        const urlPart = pathSplit[n];\n        if (routePart._type === 'path' && routePart.name !== urlPart) {\n          continue goto_routes;\n        } else if (routePart._type === 'path') {\n          continue;\n        }\n\n        if (routePart._type === 'boolean') {\n          if (urlPart === 'true' || urlPart === 'false') {\n            newState[routePart.name] = urlPart === 'true';\n            continue;\n          }\n          continue goto_routes;\n        }\n\n        if (routePart._type === 'number') {\n          const intParsed = parseInt(urlPart);\n          if (!isNaN(intParsed)) {\n            newState[routePart.name] = intParsed;\n            continue;\n          }\n\n          const floatParsed = parseFloat(urlPart);\n          if (!isNaN(floatParsed)) {\n            newState[routePart.name] = floatParsed;\n            continue;\n          }\n\n          continue goto_routes;\n        }\n\n        if (routePart._type === 'string') {\n          const match = urlPart.match(stringType);\n          if (match) {\n            newState[routePart.name] = urlPart;\n            continue;\n          }\n          continue goto_routes;\n        }\n\n        throw new Error(`Unable to identify path part ${urlPart} ${routePart}`)\n      }\n\n      for (let param of routeParams) {\n        const name = param[0];\n        const options = param[1]\n        let paramValue = url.searchParams.get(name);\n\n        if (paramValue === null && options._default) {\n          newState[name] = options._default;\n        }\n\n        if (paramValue === null) {\n          continue;\n        }\n\n        if (options._type === 'boolean') {\n          if (paramValue === 'true' || paramValue === 'false') {\n            newState[name] = paramValue === 'true';\n          } else {\n            throw new Error(`Invalid boolean for param: ${name} boolean: ${paramValue}`);\n          }\n        }\n\n        if (options._type === 'number') {\n          const intParsed = parseInt(paramValue);\n          const floatParsed = parseFloat(paramValue);\n          if (!isNaN(intParsed)) {\n            newState[name] = intParsed;\n          } else if (!isNaN(floatParsed)) {\n            newState[name] = floatParsed;\n          } else {\n            throw new Error(`Invalid number for param: ${name} number ${paramValue}`);\n          }\n        }\n\n      }\n\n      return {name: name, state: newState};\n    }\n  }\n\n  throw new Error(`No valid route found for url: ${hash}`);\n}\n\nexport function formatUrl(\n  name: string,\n  params: {[key: string]: string | number | boolean},\n  routes: Map<string, Route>\n) {\n  params = params || {};\n  const route = routes.get(name);\n  const pathParts = [];\n  if (route) {\n    for (let routePart of route.path) {\n      if (routePart._type === 'path') {\n        pathParts.push(routePart.name);\n        continue;\n      }\n\n      let value = params[routePart.name];\n      if (!value) {\n        throw new Error(`Path param ${routePart.name} not found while generating url for ${name}`);\n      }\n      pathParts.push(value);\n    }\n    const formattedParams = [];\n    for (const param of route.params.entries()) {\n      const paramName = param[0];\n      const details = param[1];\n      let paramValue = params[paramName];\n      let value: string | boolean | number | null = null;\n      if (!paramValue) {\n        value = details._default;\n      }\n\n      if (value) {\n        formattedParams.push(`${paramName}=${value}`);\n        continue;\n      }\n\n      throw new Error(`Query param ${paramName} not found and no default while generating url for ${name}`);\n    }\n\n    if (formattedParams.length > 0) {\n      return `/${pathParts.join('/')}?${formattedParams.join('&')}`;\n    }\n    return `/${pathParts.join('/')}`;\n  } else {\n    throw new Error(`No route found for name ${name}`);\n  }\n}\n\nconst RoutingContext = React.createContext(null);\nconst parsedRoutes = new Map();\n\ntype CurrentRoute = {\n  name: string;\n  state: RouteState;\n};\n\nexport function useRouter(component: JSX.Element, routes: {[key: string]: string}) {\n  const [currentRoute, setCurrentRoute] = (React.useState(null) as [CurrentRoute | null, any]);\n\n  Object.entries(routes).forEach((nameRoute) => {\n    parsedRoutes.set(nameRoute[0], parseRoute(nameRoute[1]));\n  });\n\n  let routingValue: any = null;\n  if (currentRoute) {\n    routingValue = {\n      back() {\n        window.history.back();\n      },\n      forward() {\n        window.history.forward();\n      },\n      navigate(name: string, params: {[key: string]: string | number | boolean}) {\n        const url = formatUrl(name, params, parsedRoutes);\n        window.location.hash = url;\n      },\n      name: currentRoute.name,\n      state: currentRoute.state,\n    };\n  }\n\n  React.useEffect(() => {\n    function hashChange(event?: HashChangeEvent) {\n      if (event) {\n        event.preventDefault();\n      }\n      const route = matchRouteAndGenerateState(window.location.hash, parsedRoutes);\n      setCurrentRoute(route);\n    }\n\n    window.addEventListener(\"hashchange\", hashChange, false);\n    hashChange();\n\n    return (function () {\n      window.removeEventListener(\"hashchange\", hashChange, false);\n    });\n  }, []);\n\n  return (\n    <RoutingContext.Provider value={routingValue}>\n      {component}\n    </RoutingContext.Provider>\n  );\n}\n\nexport function useRouting() {\n  const currentRoute = React.useContext(RoutingContext);\n  return currentRoute;\n}\n\n"],"names":["const","VALID_IDENTIFIER","stringType","parseRoute","route","url","URL","segments","params","Map","typePath","RegExp","partPath","pathname","split","let","part","match","push","name","type","_default","Error","searchParams","entry","key","value","set","parseFloat","parseInt","path","matchRouteAndGenerateState","hash","routes","replace","pathSplit","filter","newState","goto_routes","nameRoute","routePath","routeParams","length","n","routePart","urlPart","_type","intParsed","isNaN","floatParsed","param","options","paramValue","get","state","formatUrl","pathParts","formattedParams","entries","paramName","join","RoutingContext","React.createContext","parsedRoutes","useRouter","component","React.useState","Object","forEach","routingValue","currentRoute","back","window","history","forward","navigate","location","React.useEffect","hashChange","event","preventDefault","setCurrentRoute","addEventListener","removeEventListener","React.createElement","Provider","useRouting","React.useContext"],"mappings":"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"}